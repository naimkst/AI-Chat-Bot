{"version":3,"file":"use-uploadthing-be6B2S--.js","names":["noop","callback: TCallback","fetch: FetchEsque","url?: string","options?: RequestInit","initialState: State<T>","state: State<T>","action: Action<T>","initialState","state","fetch: FetchEsque","url: URL","endpoint: string","endpoint: EndpointArg<TRouter, TEndpoint>","opts?: UseUploadthingProps<TRouter[TEndpoint]>","error: UploadThingError<inferErrorShape<TRouter[TEndpoint]>>","initOpts?: GenerateTypedHelpersOptions","uploadthingClientVersion","slug: EndpointArg<TRouter, keyof TRouter>"],"sources":["../package.json","../src/utils/useEvent.ts","../src/utils/useFetch.ts","../src/use-uploadthing.ts"],"sourcesContent":["{\n  \"name\": \"@uploadthing/react\",\n  \"version\": \"7.3.2\",\n  \"type\": \"module\",\n  \"sideEffects\": false,\n  \"license\": \"MIT\",\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"exports\": {\n    \"./package.json\": \"./package.json\",\n    \"./styles.css\": \"./dist/index.css\",\n    \".\": {\n      \"import\": {\n        \"types\": \"./dist/index.d.ts\",\n        \"default\": \"./dist/index.js\"\n      },\n      \"require\": {\n        \"types\": \"./dist/index.d.cts\",\n        \"default\": \"./dist/index.cjs\"\n      }\n    },\n    \"./native\": {\n      \"import\": {\n        \"types\": \"./native/index.d.ts\",\n        \"default\": \"./native/index.js\"\n      },\n      \"require\": {\n        \"types\": \"./native/index.d.cts\",\n        \"default\": \"./native/index.cjs\"\n      }\n    },\n    \"./next-ssr-plugin\": {\n      \"import\": {\n        \"types\": \"./next-ssr-plugin/index.d.ts\",\n        \"default\": \"./next-ssr-plugin/index.js\"\n      },\n      \"require\": {\n        \"types\": \"./next-ssr-plugin/index.d.cts\",\n        \"default\": \"./next-ssr-plugin/index.cjs\"\n      }\n    }\n  },\n  \"files\": [\n    \"dist\",\n    \"native\",\n    \"next-ssr-plugin\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"scripts\": {\n    \"build\": \"tsdown\",\n    \"dev\": \"tsdown --no-clean\",\n    \"clean\": \"git clean -xdf dist hooks native next-ssr-plugin node_modules\",\n    \"lint\": \"eslint src test --max-warnings 0\",\n    \"prepack\": \"bun ../../.github/replace-workspace-protocol.ts\",\n    \"test\": \"vitest run\",\n    \"typecheck\": \"tsc --noEmit\"\n  },\n  \"dependencies\": {\n    \"@uploadthing/shared\": \"workspace:*\",\n    \"file-selector\": \"0.6.0\"\n  },\n  \"peerDependencies\": {\n    \"next\": \"*\",\n    \"react\": \"^17.0.2 || ^18.0.0 || ^19.0.0\",\n    \"uploadthing\": \"^7.2.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"next\": {\n      \"optional\": true\n    }\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^22.10.0\",\n    \"@types/react\": \"19.1.2\",\n    \"@types/react-dom\": \"19.1.2\",\n    \"@uploadthing/eslint-config\": \"workspace:*\",\n    \"@uploadthing/tsconfig\": \"workspace:*\",\n    \"@uploadthing/vitest-config\": \"workspace:*\",\n    \"@vitest/browser\": \"3.2.4\",\n    \"@vitest/coverage-istanbul\": \"3.2.4\",\n    \"concurrently\": \"^9.1.2\",\n    \"eslint\": \"9.25.1\",\n    \"msw\": \"2.7.5\",\n    \"next\": \"15.3.1\",\n    \"react\": \"19.1.0\",\n    \"react-dom\": \"19.1.0\",\n    \"tailwindcss\": \"^3.4.16\",\n    \"tsdown\": \"0.12.1\",\n    \"typescript\": \"5.8.3\",\n    \"uploadthing\": \"workspace:*\",\n    \"vitest\": \"3.2.4\",\n    \"vitest-browser-react\": \"0.3.0\",\n    \"wait-on\": \"^8.0.1\",\n    \"zod\": \"^3.24.1\"\n  }\n}\n","// Ripped from https://github.com/scottrippey/react-use-event-hook\nimport React from \"react\";\n\ntype AnyFunction = (...args: any[]) => any;\nconst noop = () => void 0;\n\n/**\n * Suppress the warning when using useLayoutEffect with SSR. (https://reactjs.org/link/uselayouteffect-ssr)\n * Make use of useInsertionEffect if available.\n */\nconst useInsertionEffect =\n  typeof window !== \"undefined\" ? React.useInsertionEffect : noop;\n\n/**\n * Similar to useCallback, with a few subtle differences:\n * - The returned function is a stable reference, and will always be the same between renders\n * - No dependency lists required\n * - Properties or state accessed within the callback will always be \"current\"\n */\nexport function useEvent<TCallback extends AnyFunction>(\n  callback: TCallback,\n): TCallback {\n  // Keep track of the latest callback:\n  const latestRef = React.useRef<TCallback>(\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    useEvent_shouldNotBeInvokedBeforeMount as any,\n  );\n  useInsertionEffect(() => {\n    latestRef.current = callback;\n  }, [callback]);\n\n  // Create a stable callback that always calls the latest callback:\n  // using useRef instead of useCallback avoids creating and empty array on every render\n  const stableRef = React.useRef<TCallback>(null);\n\n  stableRef.current ??= function (this: any) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, prefer-rest-params, @typescript-eslint/no-unsafe-argument\n    return latestRef.current.apply(this, arguments as any);\n  } as TCallback;\n\n  return stableRef.current;\n}\n\n/**\n * Render methods should be pure, especially when concurrency is used,\n * so we will throw this error if the callback is called while rendering.\n */\nfunction useEvent_shouldNotBeInvokedBeforeMount() {\n  throw new Error(\n    \"INVALID_USEEVENT_INVOCATION: the callback from useEvent cannot be invoked before the component has mounted.\",\n  );\n}\n","// Ripped from https://usehooks-ts.com/react-hook/use-fetch\nimport { useEffect, useReducer, useRef } from \"react\";\n\nimport type { FetchEsque } from \"@uploadthing/shared\";\nimport { safeParseJSON } from \"@uploadthing/shared\";\n\ninterface State<T> {\n  data?: T | undefined;\n  error?: Error | undefined;\n}\n\ntype Cache<T> = Record<string, T>;\n\n// discriminated union type\ntype Action<T> =\n  | { type: \"loading\" }\n  | { type: \"fetched\"; payload: T }\n  | { type: \"error\"; payload: Error };\n\nfunction useFetch<T = unknown>(\n  fetch: FetchEsque,\n  url?: string,\n  options?: RequestInit,\n): State<T> {\n  const cache = useRef<Cache<T>>({});\n\n  // Used to prevent state update if the component is unmounted\n  const cancelRequest = useRef<boolean>(false);\n\n  const initialState: State<T> = {\n    error: undefined,\n    data: undefined,\n  };\n\n  // Keep state logic separated\n  const fetchReducer = (state: State<T>, action: Action<T>): State<T> => {\n    switch (action.type) {\n      case \"loading\":\n        return { ...initialState };\n      case \"fetched\":\n        return { ...initialState, data: action.payload };\n      case \"error\":\n        return { ...initialState, error: action.payload };\n      default:\n        return state;\n    }\n  };\n\n  const [state, dispatch] = useReducer(fetchReducer, initialState);\n\n  useEffect(() => {\n    // Do nothing if the url is not given\n    if (!url) return;\n\n    cancelRequest.current = false;\n\n    const fetchData = async () => {\n      dispatch({ type: \"loading\" });\n\n      // If a cache exists for this url, return it\n      if (cache.current[url]) {\n        dispatch({ type: \"fetched\", payload: cache.current[url] });\n        return;\n      }\n\n      try {\n        const response = await fetch(url, options);\n        if (!response.ok) {\n          throw new Error(response.statusText);\n        }\n\n        const dataOrError = await safeParseJSON<T>(response);\n        if (dataOrError instanceof Error) {\n          throw dataOrError;\n        }\n\n        cache.current[url] = dataOrError;\n        if (cancelRequest.current) return;\n\n        dispatch({ type: \"fetched\", payload: dataOrError });\n      } catch (error) {\n        if (cancelRequest.current) return;\n\n        dispatch({ type: \"error\", payload: error as Error });\n      }\n    };\n\n    void fetchData();\n\n    // Use the cleanup function for avoiding a possibly...\n    // ...state update after the component was unmounted\n    return () => {\n      cancelRequest.current = true;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [url]);\n\n  return state;\n}\n\nexport default useFetch;\n","import { useRef, useState } from \"react\";\n\nimport type {\n  EndpointMetadata,\n  ExpandedRouteConfig,\n  FetchEsque,\n} from \"@uploadthing/shared\";\nimport {\n  INTERNAL_DO_NOT_USE__fatalClientError,\n  resolveMaybeUrlArg,\n  roundProgress,\n  unwrap,\n  UploadAbortedError,\n  UploadThingError,\n  warnIfInvalidPeerDependency,\n} from \"@uploadthing/shared\";\nimport {\n  genUploader,\n  version as uploadthingClientVersion,\n} from \"uploadthing/client\";\nimport type {\n  EndpointArg,\n  FileRouter,\n  inferEndpointInput,\n  inferErrorShape,\n} from \"uploadthing/types\";\n\nimport { peerDependencies } from \"../package.json\";\nimport type { GenerateTypedHelpersOptions, UseUploadthingProps } from \"./types\";\nimport { useEvent } from \"./utils/useEvent\";\nimport useFetch from \"./utils/useFetch\";\n\ndeclare const globalThis: {\n  __UPLOADTHING?: EndpointMetadata;\n  fetch: FetchEsque;\n};\n\nconst useRouteConfig = (\n  fetch: FetchEsque,\n  url: URL,\n  endpoint: string,\n): ExpandedRouteConfig | undefined => {\n  const maybeServerData = globalThis.__UPLOADTHING;\n  const { data } = useFetch<EndpointMetadata>(\n    fetch,\n    // Don't fetch if we already have the data\n    maybeServerData ? undefined : url.href,\n  );\n  return (maybeServerData ?? data)?.find((x) => x.slug === endpoint)?.config;\n};\n\n/**\n * @internal - This is an internal function. Use `generateReactHelpers` instead.\n * The actual hook we export for public usage is generated from `generateReactHelpers`\n * which has the URL and FileRouter generic pre-bound.\n */\nfunction useUploadThingInternal<\n  TRouter extends FileRouter,\n  TEndpoint extends keyof TRouter,\n>(\n  url: URL,\n  endpoint: EndpointArg<TRouter, TEndpoint>,\n  fetch: FetchEsque,\n  opts?: UseUploadthingProps<TRouter[TEndpoint]>,\n) {\n  const progressGranularity = opts?.uploadProgressGranularity ?? \"coarse\";\n  const { uploadFiles, routeRegistry } = genUploader<TRouter>({\n    fetch,\n    url,\n    package: \"@uploadthing/react\",\n  });\n\n  const [isUploading, setUploading] = useState(false);\n  const uploadProgress = useRef(0);\n  const fileProgress = useRef<Map<File, number>>(new Map());\n\n  type InferredInput = inferEndpointInput<TRouter[TEndpoint]>;\n  type FuncInput = undefined extends InferredInput\n    ? [files: File[], input?: undefined]\n    : [files: File[], input: InferredInput];\n\n  const startUpload = useEvent(async (...args: FuncInput) => {\n    const files = (await opts?.onBeforeUploadBegin?.(args[0])) ?? args[0];\n    const input = args[1];\n\n    setUploading(true);\n    files.forEach((f) => fileProgress.current.set(f, 0));\n    opts?.onUploadProgress?.(0);\n    try {\n      const res = await uploadFiles<TEndpoint>(endpoint, {\n        signal: opts?.signal,\n        headers: opts?.headers,\n        files,\n        onUploadProgress: (progress) => {\n          if (!opts?.onUploadProgress) return;\n          fileProgress.current.set(progress.file, progress.progress);\n          let sum = 0;\n          fileProgress.current.forEach((p) => {\n            sum += p;\n          });\n          const averageProgress = roundProgress(\n            Math.min(100, sum / fileProgress.current.size),\n            progressGranularity,\n          );\n          if (averageProgress !== uploadProgress.current) {\n            opts.onUploadProgress(averageProgress);\n            uploadProgress.current = averageProgress;\n          }\n        },\n        onUploadBegin({ file }) {\n          if (!opts?.onUploadBegin) return;\n\n          opts.onUploadBegin(file);\n        },\n        // @ts-expect-error - input may not be defined on the type\n        input,\n      });\n\n      await opts?.onClientUploadComplete?.(res);\n      return res;\n    } catch (e) {\n      /**\n       * This is the only way to introduce this as a non-breaking change\n       * TODO: Consider refactoring API in the next major version\n       */\n      if (e instanceof UploadAbortedError) throw e;\n\n      let error: UploadThingError<inferErrorShape<TRouter[TEndpoint]>>;\n      if (e instanceof UploadThingError) {\n        error = e as UploadThingError<inferErrorShape<TRouter[TEndpoint]>>;\n      } else {\n        error = INTERNAL_DO_NOT_USE__fatalClientError(e as Error);\n        // eslint-disable-next-line no-console\n        console.error(\n          \"Something went wrong. Please contact UploadThing and provide the following cause:\",\n          error.cause instanceof Error ? error.cause.toString() : error.cause,\n        );\n      }\n      await opts?.onUploadError?.(error);\n    } finally {\n      setUploading(false);\n      fileProgress.current = new Map();\n      uploadProgress.current = 0;\n    }\n  });\n\n  const _endpoint = unwrap(endpoint, routeRegistry);\n  const routeConfig = useRouteConfig(fetch, url, _endpoint as string);\n\n  return {\n    startUpload,\n    isUploading,\n    routeConfig,\n  } as const;\n}\n\n/** @internal - This is an internal function. Use `generateReactHelpers` instead. */\nexport const __useUploadThingInternal = useUploadThingInternal;\n\nexport const generateReactHelpers = <TRouter extends FileRouter>(\n  initOpts?: GenerateTypedHelpersOptions,\n) => {\n  warnIfInvalidPeerDependency(\n    \"@uploadthing/react\",\n    peerDependencies.uploadthing,\n    uploadthingClientVersion,\n  );\n\n  const fetch = initOpts?.fetch ?? globalThis.fetch;\n  const url = resolveMaybeUrlArg(initOpts?.url);\n\n  const clientHelpers = genUploader<TRouter>({\n    fetch,\n    url,\n    package: \"@uploadthing/react\",\n  });\n\n  function useUploadThing<TEndpoint extends keyof TRouter>(\n    endpoint: EndpointArg<TRouter, TEndpoint>,\n    opts?: UseUploadthingProps<TRouter[TEndpoint]>,\n  ) {\n    return __useUploadThingInternal(url, endpoint, fetch, opts);\n  }\n\n  function getRouteConfig(slug: EndpointArg<TRouter, keyof TRouter>) {\n    const maybeServerData = globalThis.__UPLOADTHING;\n    const endpoint = unwrap(slug, clientHelpers.routeRegistry);\n    const config = maybeServerData?.find((x) => x.slug === endpoint)?.config;\n    if (!config) {\n      throw new Error(\n        `No config found for endpoint \"${endpoint.toString()}\". Please make sure to use the NextSSRPlugin in your Next.js app.`,\n      );\n    }\n    return config;\n  }\n\n  return {\n    useUploadThing,\n    ...clientHelpers,\n    /**\n     * Get the config for a given endpoint outside of React context.\n     * @remarks Can only be used if the NextSSRPlugin is used in the app.\n     */\n    getRouteConfig,\n  } as const;\n};\n"],"mappings":"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"}