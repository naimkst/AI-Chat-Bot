{"version":3,"file":"upload-builder-e0_p9NOT.js","names":["options: unknown","preferredRegion: string | undefined","error: UploadThingError","router: FileRouter","schema: S.Schema<TChunk>","onChunk: (chunk: TChunk) => Effect.Effect<void>","stream: Stream.Stream<Uint8Array, E, R>","validChunks: unknown[]","name?: string","level","Layer","message: string","opts?: {\n    /** Level to log on, default \"Debug\" */\n    level?: LogLevel.Literal;\n    /** What body mixin to use to get the response body, default \"json\" */\n    mixin?: HttpClientResponseMixinMethod;\n  }","response: HttpClientResponse.HttpClientResponse","Effect","err: HttpClientError.HttpClientError | HttpBody.HttpBodyError","parser: TParser","type: FileRouterInputKey","max: FileSize","actual: number","boundtype: \"minimum\" | \"maximum\"","bound: number","files: S.Schema.Type<typeof UploadActionPayload>[\"files\"]","routeConfig: ExpandedRouteConfig","counts: Record<string, number>","router: TRouter","fetch: FetchEsque","config: unknown","makeAdapterArgs: (...args: Args) => Effect.Effect<AdapterArgs>","toRequest: (...args: Args) => Effect.Effect<Request>","opts: RouteHandlerOptions<FileRouter>","beAdapter?: string","opts: RouteHandlerOptions<TRouter>","beAdapter: string","Schema","opts: { uploadable: AnyFileRoute }","opts: {\n  uploadable: AnyFileRoute;\n  fePackage: string;\n  beAdapter: string;\n}","opts: {\n  json: typeof UploadActionPayload.Type;\n  uploadable: AnyFileRoute;\n}","opts: {\n  uploadable: AnyFileRoute;\n  fePackage: string;\n  beAdapter: string;\n  slug: string;\n}","err: HttpClientError.ResponseError","chunk: string","initDef: Partial<AnyFileRoute>","_def: AnyFileRoute","opts?: CreateBuilderOptions<TErrorShape>","input: FileRouterInputConfig","config?: TRouteOptions"],"sources":["../src/_internal/config.ts","../src/_internal/error-formatter.ts","../src/_internal/jsonl.ts","../src/_internal/logger.ts","../src/_internal/parser.ts","../src/_internal/route-config.ts","../src/_internal/runtime.ts","../src/_internal/types.ts","../src/_internal/handler.ts","../src/_internal/upload-builder.ts"],"sourcesContent":["import * as Config from \"effect/Config\";\nimport * as ConfigProvider from \"effect/ConfigProvider\";\nimport * as Effect from \"effect/Effect\";\nimport * as S from \"effect/Schema\";\n\nimport {\n  filterDefinedObjectValues,\n  UploadThingError,\n} from \"@uploadthing/shared\";\n\nimport { UploadThingToken } from \"./shared-schemas\";\n\nexport { version as UPLOADTHING_VERSION } from \"../../package.json\";\n\n/**\n * Merge in `import.meta.env` to the built-in `process.env` provider\n * Prefix keys with `UPLOADTHING_` so we can reference just the name.\n * @example\n * process.env.UPLOADTHING_TOKEN = \"foo\"\n * Config.string(\"token\"); // Config<\"foo\">\n */\nconst envProvider = ConfigProvider.fromEnv().pipe(\n  ConfigProvider.orElse(() =>\n    ConfigProvider.fromMap(\n      new Map(\n        Object.entries(\n          filterDefinedObjectValues(\n            // fuck this I give up. import.meta is a mistake, someone else can fix it\n            (\n              import.meta as unknown as\n                | { env: Record<string, string> }\n                | undefined\n            )?.env ?? {},\n          ),\n        ),\n      ),\n      {\n        pathDelim: \"_\",\n      },\n    ),\n  ),\n  ConfigProvider.nested(\"uploadthing\"),\n  ConfigProvider.constantCase,\n);\n\n/**\n * Config provider that merges the options from the object\n * and environment variables prefixed with `UPLOADTHING_`.\n * @remarks Options take precedence over environment variables.\n */\nexport const configProvider = (options: unknown) =>\n  ConfigProvider.fromJson(options ?? {}).pipe(\n    ConfigProvider.orElse(() => envProvider),\n  );\n\nexport const IsDevelopment = Config.boolean(\"isDev\").pipe(\n  Config.orElse(() =>\n    Config.succeed(\n      typeof process !== \"undefined\" ? process.env.NODE_ENV : undefined,\n    ).pipe(Config.map((_) => _ === \"development\")),\n  ),\n  Config.withDefault(false),\n);\n\nexport const UTToken = S.Config(\"token\", UploadThingToken).pipe(\n  Effect.catchTags({\n    ConfigError: (e) =>\n      new UploadThingError({\n        code: e._op === \"InvalidData\" ? \"INVALID_SERVER_CONFIG\" : \"MISSING_ENV\",\n        message:\n          e._op === \"InvalidData\"\n            ? \"Invalid token. A token is a base64 encoded JSON object matching { apiKey: string, appId: string, regions: string[] }.\"\n            : \"Missing token. Please set the `UPLOADTHING_TOKEN` environment variable or provide a token manually through config.\",\n        cause: e,\n      }),\n  }),\n);\n\nexport const ApiUrl = Config.string(\"apiUrl\").pipe(\n  Config.withDefault(\"https://api.uploadthing.com\"),\n  Config.mapAttempt((_) => new URL(_)),\n  Config.map((url) => url.href.replace(/\\/$/, \"\")),\n);\n\nexport const IngestUrl = Effect.fn(function* (\n  preferredRegion: string | undefined,\n) {\n  const { regions, ingestHost } = yield* UTToken;\n\n  const region = preferredRegion\n    ? (regions.find((r) => r === preferredRegion) ?? regions[0])\n    : regions[0];\n\n  return yield* Config.string(\"ingestUrl\").pipe(\n    Config.withDefault(`https://${region}.${ingestHost}`),\n    Config.mapAttempt((_) => new URL(_)),\n    Config.map((url) => url.href.replace(/\\/$/, \"\")),\n  );\n});\n\nexport const UtfsHost = Config.string(\"utfsHost\").pipe(\n  Config.withDefault(\"utfs.io\"),\n);\n\nexport const UfsHost = Config.string(\"ufsHost\").pipe(\n  Config.withDefault(\"ufs.sh\"),\n);\n\nexport const UfsAppIdLocation = Config.literal(\n  \"subdomain\",\n  \"path\",\n)(\"ufsAppIdLocation\").pipe(Config.withDefault(\"subdomain\"));\n","import type { UploadThingError } from \"@uploadthing/shared\";\n\nimport type { FileRouter, inferErrorShape } from \"../types\";\n\nexport function defaultErrorFormatter(error: UploadThingError) {\n  return {\n    message: error.message,\n  };\n}\n\nexport function formatError(\n  error: UploadThingError,\n  router: FileRouter,\n): inferErrorShape<FileRouter[string]> {\n  const firstSlug = Object.keys(router)[0];\n  const errorFormatter = firstSlug\n    ? (router[firstSlug]?.errorFormatter ?? defaultErrorFormatter)\n    : defaultErrorFormatter;\n\n  return errorFormatter(error);\n}\n","import * as Effect from \"effect/Effect\";\nimport * as S from \"effect/Schema\";\nimport * as Stream from \"effect/Stream\";\n\nexport const handleJsonLineStream =\n  <TChunk>(\n    schema: S.Schema<TChunk>,\n    onChunk: (chunk: TChunk) => Effect.Effect<void>,\n  ) =>\n  <E, R>(stream: Stream.Stream<Uint8Array, E, R>) => {\n    let buf = \"\";\n\n    return stream.pipe(\n      Stream.decodeText(),\n      Stream.mapEffect((chunk) =>\n        Effect.gen(function* () {\n          buf += chunk;\n\n          // Scan buffer for newlines\n          const parts = buf.split(\"\\n\");\n          const validChunks: unknown[] = [];\n\n          for (const part of parts) {\n            try {\n              // Attempt to parse chunk as JSON\n              validChunks.push(JSON.parse(part) as unknown);\n              // Advance buffer if parsing succeeded\n              buf = buf.slice(part.length + 1);\n            } catch {\n              //\n            }\n          }\n\n          yield* Effect.logDebug(\"Received chunks\").pipe(\n            Effect.annotateLogs(\"chunk\", chunk),\n            Effect.annotateLogs(\"parsedChunks\", validChunks),\n            Effect.annotateLogs(\"buf\", buf),\n          );\n\n          return validChunks;\n        }),\n      ),\n      Stream.mapEffect(S.decodeUnknown(S.Array(schema))),\n      Stream.mapEffect(Effect.forEach((part) => onChunk(part))),\n      Stream.runDrain,\n      Effect.withLogSpan(\"handleJsonLineStream\"),\n    );\n  };\n","import type * as HttpBody from \"@effect/platform/HttpBody\";\nimport type * as HttpClientError from \"@effect/platform/HttpClientError\";\nimport type * as HttpClientResponse from \"@effect/platform/HttpClientResponse\";\nimport * as Config from \"effect/Config\";\nimport * as ConfigError from \"effect/ConfigError\";\nimport * as Effect from \"effect/Effect\";\nimport * as Either from \"effect/Either\";\nimport * as Layer from \"effect/Layer\";\nimport * as Logger from \"effect/Logger\";\nimport * as LogLevel from \"effect/LogLevel\";\n\nimport { UploadThingError } from \"@uploadthing/shared\";\n\nimport { IsDevelopment } from \"./config\";\n\n/**\n * Config.logLevel counter-intuitively accepts LogLevel[\"label\"]\n * instead of a literal, ripping it and changing to accept literal\n * Effect 4.0 will change this to accept a literal and then we can\n * remove this and go back to the built-in validator.\n */\nconst ConfigLogLevel = (name?: string): Config.Config<LogLevel.LogLevel> => {\n  const config = Config.mapOrFail(Config.string(), (literal) => {\n    const level = LogLevel.allLevels.find((level) => level._tag === literal);\n    return level === undefined\n      ? Either.left(\n          ConfigError.InvalidData(\n            [],\n            `Expected a log level but received ${literal}`,\n          ),\n        )\n      : Either.right(level);\n  });\n  return name === undefined ? config : Config.nested(config, name);\n};\n\nexport const withMinimalLogLevel = ConfigLogLevel(\"logLevel\").pipe(\n  Config.withDefault(LogLevel.Info),\n  Effect.andThen((level) => Logger.minimumLogLevel(level)),\n  Effect.tapError((e) =>\n    Effect.logError(\"Invalid log level\").pipe(Effect.annotateLogs(\"error\", e)),\n  ),\n  Effect.catchTag(\n    \"ConfigError\",\n    (e) =>\n      new UploadThingError({\n        code: \"INVALID_SERVER_CONFIG\",\n        message: \"Invalid server configuration\",\n        cause: e,\n      }),\n  ),\n  Layer.unwrapEffect,\n);\n\nexport const LogFormat = Config.literal(\n  \"json\",\n  \"logFmt\",\n  \"structured\",\n  \"pretty\",\n)(\"logFormat\");\nexport type LogFormat = Config.Config.Success<typeof LogFormat>;\n\nexport const withLogFormat = Effect.gen(function* () {\n  const isDev = yield* IsDevelopment;\n  const logFormat = yield* LogFormat.pipe(\n    Config.withDefault(isDev ? \"pretty\" : \"json\"),\n  );\n  return Logger[logFormat];\n}).pipe(\n  Effect.catchTag(\n    \"ConfigError\",\n    (e) =>\n      new UploadThingError({\n        code: \"INVALID_SERVER_CONFIG\",\n        message: \"Invalid server configuration\",\n        cause: e,\n      }),\n  ),\n  Layer.unwrapEffect,\n);\n\ntype HttpClientResponseMixinMethod = \"json\" | \"text\" | \"arrayBuffer\" | \"None\";\n\nexport const logHttpClientResponse = (\n  message: string,\n  opts?: {\n    /** Level to log on, default \"Debug\" */\n    level?: LogLevel.Literal;\n    /** What body mixin to use to get the response body, default \"json\" */\n    mixin?: HttpClientResponseMixinMethod;\n  },\n) => {\n  const mixin = opts?.mixin ?? \"json\";\n  const level = LogLevel.fromLiteral(opts?.level ?? \"Debug\");\n\n  return (response: HttpClientResponse.HttpClientResponse) =>\n    Effect.flatMap(mixin !== \"None\" ? response[mixin] : Effect.void, () =>\n      Effect.logWithLevel(level, `${message} (${response.status})`).pipe(\n        Effect.annotateLogs(\"response\", response),\n      ),\n    );\n};\n\nexport const logHttpClientError =\n  (message: string) =>\n  (err: HttpClientError.HttpClientError | HttpBody.HttpBodyError) =>\n    err._tag === \"ResponseError\"\n      ? logHttpClientResponse(message, { level: \"Error\" })(err.response)\n      : Effect.logError(message).pipe(Effect.annotateLogs(\"error\", err));\n","import type * as Standard from \"@standard-schema/spec\";\nimport * as Cause from \"effect/Cause\";\nimport * as Data from \"effect/Data\";\nimport * as Runtime from \"effect/Runtime\";\nimport * as Schema from \"effect/Schema\";\n\nimport type { Json } from \"@uploadthing/shared\";\n\nexport type ParseFn<TType> = (input: unknown) => Promise<TType>;\n\nexport type ParserZodEsque<TInput extends Json, TParsedInput> = {\n  _input: TInput;\n  _output: TParsedInput; // if using .transform etc\n  parseAsync: ParseFn<TParsedInput>;\n};\n\n// In case we add support for more parsers later\nexport type JsonParser<In extends Json, Out = In> =\n  | ParserZodEsque<In, Out>\n  | Standard.StandardSchemaV1<In, Out>\n  | Schema.Schema<Out, In>;\n\nexport class ParserError extends Data.TaggedError(\"ParserError\")<{\n  cause: unknown;\n}> {\n  message =\n    \"Input validation failed. The original error with it's validation issues is in the error cause.\";\n}\n\nexport function getParseFn<\n  TOut extends Json,\n  TParser extends JsonParser<any, TOut>,\n>(parser: TParser): ParseFn<TOut> {\n  if (\"parseAsync\" in parser && typeof parser.parseAsync === \"function\") {\n    /**\n     * Zod\n     * TODO (next major): Consider wrapping ZodError in ParserError\n     */\n    return parser.parseAsync;\n  }\n\n  if (Schema.isSchema(parser)) {\n    /**\n     * Effect Schema\n     */\n    return (value) =>\n      Schema.decodeUnknownPromise(parser as Schema.Schema<any, TOut>)(\n        value,\n      ).catch((error) => {\n        throw new ParserError({\n          cause: Cause.squash(\n            (error as Runtime.FiberFailure)[Runtime.FiberFailureCauseId],\n          ),\n        });\n      });\n  }\n\n  if (\"~standard\" in parser) {\n    /**\n     * Standard Schema\n     * TODO (next major): Consider moving this to the top of the function\n     */\n    return async (value) => {\n      const result = await parser[\"~standard\"].validate(value);\n      if (result.issues) {\n        throw new ParserError({ cause: result.issues });\n      }\n      return result.value;\n    };\n  }\n\n  throw new Error(\"Invalid parser\");\n}\n","import * as Data from \"effect/Data\";\nimport * as Effect from \"effect/Effect\";\nimport type * as S from \"effect/Schema\";\n\nimport type {\n  ExpandedRouteConfig,\n  FileRouterInputKey,\n  FileSize,\n  InvalidFileSizeError,\n  InvalidFileTypeError,\n  UnknownFileTypeError,\n} from \"@uploadthing/shared\";\nimport {\n  bytesToFileSize,\n  fileSizeToBytes,\n  fillInputRouteConfig,\n  InvalidRouteConfigError,\n  matchFileType,\n  objectKeys,\n  UploadThingError,\n} from \"@uploadthing/shared\";\n\nimport type { FileRouter } from \"../types\";\nimport type { UploadActionPayload } from \"./shared-schemas\";\n\nclass FileSizeMismatch extends Data.Error<{\n  reason: string;\n}> {\n  readonly _tag = \"FileSizeMismatch\";\n  readonly name = \"FileSizeMismatchError\";\n  constructor(type: FileRouterInputKey, max: FileSize, actual: number) {\n    const reason = `You uploaded a ${type} file that was ${bytesToFileSize(actual)}, but the limit for that type is ${max}`;\n    super({ reason });\n  }\n}\n\nclass FileCountMismatch extends Data.Error<{\n  reason: string;\n}> {\n  readonly _tag = \"FileCountMismatch\";\n  readonly name = \"FileCountMismatchError\";\n  constructor(\n    type: FileRouterInputKey,\n    boundtype: \"minimum\" | \"maximum\",\n    bound: number,\n    actual: number,\n  ) {\n    const reason = `You uploaded ${actual} file(s) of type '${type}', but the ${boundtype} for that type is ${bound}`;\n\n    super({ reason });\n  }\n}\n\n// Verify that the uploaded files doesn't violate the route config,\n// e.g. uploading more videos than allowed, or a file that is larger than allowed.\n// This is double-checked on infra side, but we want to fail early to avoid network latency.\nexport const assertFilesMeetConfig = (\n  files: S.Schema.Type<typeof UploadActionPayload>[\"files\"],\n  routeConfig: ExpandedRouteConfig,\n): Effect.Effect<\n  null,\n  | UploadThingError\n  | FileSizeMismatch\n  | FileCountMismatch\n  | InvalidRouteConfigError\n  | UnknownFileTypeError\n  | InvalidFileTypeError\n  | InvalidFileSizeError\n> =>\n  Effect.gen(function* () {\n    const counts: Record<string, number> = {};\n\n    for (const file of files) {\n      const type = yield* matchFileType(file, objectKeys(routeConfig));\n      counts[type] = (counts[type] ?? 0) + 1;\n\n      const sizeLimit = routeConfig[type]?.maxFileSize;\n      if (!sizeLimit) {\n        return yield* new InvalidRouteConfigError(type, \"maxFileSize\");\n      }\n      const sizeLimitBytes = yield* fileSizeToBytes(sizeLimit);\n\n      if (file.size > sizeLimitBytes) {\n        return yield* new FileSizeMismatch(type, sizeLimit, file.size);\n      }\n    }\n\n    for (const _key in counts) {\n      const key = _key as FileRouterInputKey;\n      const config = routeConfig[key];\n      if (!config) return yield* new InvalidRouteConfigError(key);\n\n      const count = counts[key];\n      const min = config.minFileCount;\n      const max = config.maxFileCount;\n\n      if (min > max) {\n        return yield* new UploadThingError({\n          code: \"BAD_REQUEST\",\n          message:\n            \"Invalid config during file count - minFileCount > maxFileCount\",\n          cause: `minFileCount must be less than maxFileCount for key ${key}. got: ${min} > ${max}`,\n        });\n      }\n\n      if (count != null && count < min) {\n        return yield* new FileCountMismatch(key, \"minimum\", min, count);\n      }\n      if (count != null && count > max) {\n        return yield* new FileCountMismatch(key, \"maximum\", max, count);\n      }\n    }\n\n    return null;\n  });\n\nexport const extractRouterConfig = <TRouter extends FileRouter>(\n  router: TRouter,\n) =>\n  Effect.forEach(objectKeys(router), (slug) =>\n    Effect.map(fillInputRouteConfig(router[slug]!.routerConfig), (config) => ({\n      slug,\n      config,\n    })),\n  );\n","import * as FetchHttpClient from \"@effect/platform/FetchHttpClient\";\nimport * as Headers from \"@effect/platform/Headers\";\nimport * as FiberRef from \"effect/FiberRef\";\nimport * as Layer from \"effect/Layer\";\nimport * as ManagedRuntime from \"effect/ManagedRuntime\";\n\nimport type { FetchEsque } from \"@uploadthing/shared\";\n\nimport { configProvider } from \"./config\";\nimport { withLogFormat, withMinimalLogLevel } from \"./logger\";\n\nexport const makeRuntime = (fetch: FetchEsque, config: unknown) => {\n  const fetchHttpClient = Layer.provideMerge(\n    FetchHttpClient.layer,\n    Layer.succeed(FetchHttpClient.Fetch, fetch as typeof globalThis.fetch),\n  );\n\n  const withRedactedHeaders = Layer.effectDiscard(\n    FiberRef.update(Headers.currentRedactedNames, (_) =>\n      _.concat([\"x-uploadthing-api-key\"]),\n    ),\n  );\n\n  const layer = Layer.provide(\n    Layer.mergeAll(\n      withLogFormat,\n      withMinimalLogLevel,\n      fetchHttpClient,\n      withRedactedHeaders,\n    ),\n    Layer.setConfigProvider(configProvider(config)),\n  );\n  return ManagedRuntime.make(layer);\n};\n","import type { Schema } from \"effect/Schema\";\n\nimport type {\n  ErrorMessage,\n  FileRouterInputConfig,\n  Json,\n  JsonObject,\n  MaybePromise,\n  RouteOptions,\n  Simplify,\n  UploadThingError,\n} from \"@uploadthing/shared\";\n\nimport type { JsonParser } from \"./parser\";\nimport type {\n  FileUploadDataWithCustomId,\n  NewPresignedUrl,\n  UploadActionPayload,\n  UploadedFileData,\n} from \"./shared-schemas\";\n\nexport type UTRegionAlias =\n  | \"bom1\"\n  | \"icn1\"\n  | \"syd1\"\n  | \"can1\"\n  | \"fra1\"\n  | \"zrh1\"\n  | \"dub1\"\n  | \"cle1\"\n  | \"sfo1\"\n  | \"sea1\";\n\n/**\n * Marker used to select the region based on the incoming request\n */\nexport const UTRegion = Symbol(\"uploadthing-region-symbol\");\n\n/**\n * Marker used to append a `customId` to the incoming file data in `.middleware()`\n * @example\n * ```ts\n * .middleware((opts) => {\n *   return {\n *     [UTFiles]: opts.files.map((file) => ({\n *       ...file,\n *       customId: generateId(),\n *     }))\n *   };\n * })\n * ```\n */\nexport const UTFiles = Symbol(\"uploadthing-custom-id-symbol\");\n\nexport type UnsetMarker = \"unsetMarker\" & {\n  __brand: \"unsetMarker\";\n};\n\nexport type ValidMiddlewareObject = {\n  [UTRegion]?: UTRegionAlias;\n  [UTFiles]?: Partial<FileUploadDataWithCustomId>[];\n  [key: string]: unknown;\n};\n\nexport interface AnyParams {\n  _routeOptions: any;\n  _input: {\n    in: any;\n    out: any;\n  };\n  _metadata: any; // imaginary field used to bind metadata return type to an Upload resolver\n  _adapterFnArgs: Record<string, unknown>;\n  _errorShape: any;\n  _errorFn: any; // used for onUploadError\n  _output: any;\n}\n\ntype MiddlewareFn<\n  TInput extends Json | UnsetMarker,\n  TOutput extends ValidMiddlewareObject,\n  TArgs extends Record<string, unknown>,\n> = (\n  opts: TArgs & {\n    files: Schema.Type<typeof UploadActionPayload>[\"files\"];\n    input: TInput extends UnsetMarker ? undefined : TInput;\n  },\n) => MaybePromise<TOutput>;\n\ntype UploadCompleteFn<\n  TMetadata,\n  TOutput extends JsonObject | void,\n  TArgs extends Record<string, unknown>,\n> = (\n  opts: TArgs & {\n    metadata: TMetadata;\n    file: UploadedFileData;\n  },\n) => MaybePromise<TOutput>;\n\ntype UploadErrorFn<TArgs extends Record<string, unknown>> = (\n  input: TArgs & {\n    error: UploadThingError;\n    fileKey: string;\n  },\n) => MaybePromise<void>;\n\nexport interface UploadBuilder<TParams extends AnyParams> {\n  input: <TIn extends Json, TOut>(\n    parser: TParams[\"_input\"][\"in\"] extends UnsetMarker\n      ? JsonParser<TIn, TOut>\n      : ErrorMessage<\"input is already set\">,\n  ) => UploadBuilder<{\n    _routeOptions: TParams[\"_routeOptions\"];\n    _input: { in: TIn; out: TOut };\n    _metadata: TParams[\"_metadata\"];\n    _adapterFnArgs: TParams[\"_adapterFnArgs\"];\n    _errorShape: TParams[\"_errorShape\"];\n    _errorFn: TParams[\"_errorFn\"];\n    _output: UnsetMarker;\n  }>;\n  middleware: <TOutput extends ValidMiddlewareObject>(\n    fn: TParams[\"_metadata\"] extends UnsetMarker\n      ? MiddlewareFn<\n          TParams[\"_input\"][\"out\"],\n          TOutput,\n          TParams[\"_adapterFnArgs\"]\n        >\n      : ErrorMessage<\"middleware is already set\">,\n  ) => UploadBuilder<{\n    _routeOptions: TParams[\"_routeOptions\"];\n    _input: TParams[\"_input\"];\n    _metadata: TOutput;\n    _adapterFnArgs: TParams[\"_adapterFnArgs\"];\n    _errorShape: TParams[\"_errorShape\"];\n    _errorFn: TParams[\"_errorFn\"];\n    _output: UnsetMarker;\n  }>;\n  onUploadError: (\n    fn: TParams[\"_errorFn\"] extends UnsetMarker\n      ? UploadErrorFn<TParams[\"_adapterFnArgs\"]>\n      : ErrorMessage<\"onUploadError is already set\">,\n  ) => UploadBuilder<{\n    _routeOptions: TParams[\"_routeOptions\"];\n    _input: TParams[\"_input\"];\n    _metadata: TParams[\"_metadata\"];\n    _adapterFnArgs: TParams[\"_adapterFnArgs\"];\n    _errorShape: TParams[\"_errorShape\"];\n    _errorFn: UploadErrorFn<TParams[\"_adapterFnArgs\"]>;\n    _output: UnsetMarker;\n  }>;\n  onUploadComplete: <TOutput extends JsonObject | void>(\n    fn: UploadCompleteFn<\n      Simplify<\n        TParams[\"_metadata\"] extends UnsetMarker\n          ? undefined\n          : Omit<TParams[\"_metadata\"], typeof UTFiles | typeof UTRegion>\n      >,\n      TOutput,\n      TParams[\"_adapterFnArgs\"]\n    >,\n  ) => FileRoute<{\n    input: TParams[\"_input\"][\"in\"] extends UnsetMarker\n      ? undefined\n      : TParams[\"_input\"][\"in\"];\n    output: TParams[\"_routeOptions\"][\"awaitServerData\"] extends false\n      ? null\n      : TOutput extends void | undefined // JSON serialization\n        ? null\n        : TOutput;\n    errorShape: TParams[\"_errorShape\"];\n  }>;\n}\n\nexport type AnyBuiltUploaderTypes = {\n  input: any;\n  output: any;\n  errorShape: any;\n};\n\nexport interface FileRoute<TTypes extends AnyBuiltUploaderTypes> {\n  $types: TTypes;\n  routerConfig: FileRouterInputConfig;\n  routeOptions: RouteOptions;\n  inputParser: JsonParser<any>;\n  middleware: MiddlewareFn<any, ValidMiddlewareObject, any>;\n  onUploadError: UploadErrorFn<any>;\n  errorFormatter: (err: UploadThingError) => any;\n  onUploadComplete: UploadCompleteFn<any, any, any>;\n}\nexport type AnyFileRoute = FileRoute<AnyBuiltUploaderTypes>;\n\n/**\n * Map actionType to the required payload for that action\n * @todo Look into using @effect/rpc :thinking:\n */\nexport type UTEvents = {\n  upload: {\n    in: UploadActionPayload;\n    out: ReadonlyArray<NewPresignedUrl>;\n  };\n};\n\n/**\n * Result from the PUT request to the UploadThing Ingest server\n */\nexport type UploadPutResult<TServerOutput = unknown> = {\n  ufsUrl: string;\n  /**\n   * @deprecated\n   * This field will be removed in uploadthing v9. Use `ufsUrl` instead.\n   */\n  url: string;\n  /**\n   * @deprecated\n   * This field will be removed in uploadthing v9. Use `ufsUrl` instead.\n   */\n  appUrl: string;\n  fileHash: string;\n  serverData: TServerOutput;\n};\n","import * as HttpApp from \"@effect/platform/HttpApp\";\nimport * as HttpBody from \"@effect/platform/HttpBody\";\nimport * as HttpClient from \"@effect/platform/HttpClient\";\nimport type * as HttpClientError from \"@effect/platform/HttpClientError\";\nimport * as HttpClientRequest from \"@effect/platform/HttpClientRequest\";\nimport * as HttpClientResponse from \"@effect/platform/HttpClientResponse\";\nimport * as HttpRouter from \"@effect/platform/HttpRouter\";\nimport * as HttpServerRequest from \"@effect/platform/HttpServerRequest\";\nimport * as HttpServerResponse from \"@effect/platform/HttpServerResponse\";\nimport * as Config from \"effect/Config\";\nimport * as Context from \"effect/Context\";\nimport * as Effect from \"effect/Effect\";\nimport * as Match from \"effect/Match\";\nimport * as Redacted from \"effect/Redacted\";\nimport * as Schema from \"effect/Schema\";\n\nimport {\n  fillInputRouteConfig,\n  generateKey,\n  generateSignedURL,\n  getStatusCodeFromError,\n  matchFileType,\n  objectKeys,\n  UploadThingError,\n  verifySignature,\n} from \"@uploadthing/shared\";\n\nimport * as pkgJson from \"../../package.json\";\nimport type { FileRouter, RouteHandlerOptions } from \"../types\";\nimport { IngestUrl, IsDevelopment, UTToken } from \"./config\";\nimport { logDeprecationWarning } from \"./deprecations\";\nimport { formatError } from \"./error-formatter\";\nimport { handleJsonLineStream } from \"./jsonl\";\nimport { logHttpClientError, logHttpClientResponse } from \"./logger\";\nimport { getParseFn } from \"./parser\";\nimport { assertFilesMeetConfig, extractRouterConfig } from \"./route-config\";\nimport { makeRuntime } from \"./runtime\";\nimport {\n  ActionType,\n  CallbackResultResponse,\n  MetadataFetchResponse,\n  MetadataFetchStreamPart,\n  UploadActionPayload,\n  UploadedFileData,\n  UploadThingHook,\n} from \"./shared-schemas\";\nimport { UTFiles, UTRegion } from \"./types\";\nimport type { AnyFileRoute, UTEvents } from \"./types\";\n\nexport class AdapterArguments extends Context.Tag(\n  \"uploadthing/AdapterArguments\",\n)<AdapterArguments, Record<string, unknown>>() {}\n\n/**\n * Create a request handler adapter for any framework or server library.\n * Refer to the existing adapters for examples on how to use this function.\n * @public\n *\n * @param makeAdapterArgs - Function that takes the args from your framework and returns an Effect that resolves to the adapter args.\n * These args are passed to the `.middleware`, `.onUploadComplete`, and `.onUploadError` hooks.\n * @param toRequest - Function that takes the args from your framework and returns an Effect that resolves to a web Request object.\n * @param opts - The router config and other options that are normally passed to `createRequestHandler` of official adapters\n * @param beAdapter - [Optional] The adapter name of the adapter, used for telemetry purposes\n * @returns A function that takes the args from your framework and returns a promise that resolves to a Response object.\n */\nexport const makeAdapterHandler = <\n  Args extends any[],\n  AdapterArgs extends Record<string, unknown>,\n>(\n  makeAdapterArgs: (...args: Args) => Effect.Effect<AdapterArgs>,\n  toRequest: (...args: Args) => Effect.Effect<Request>,\n  opts: RouteHandlerOptions<FileRouter>,\n  beAdapter?: string,\n): ((...args: Args) => Promise<Response>) => {\n  const managed = makeRuntime(\n    opts.config?.fetch as typeof globalThis.fetch,\n    opts.config,\n  );\n  const handle = Effect.promise(() =>\n    managed.runtime().then(HttpApp.toWebHandlerRuntime),\n  );\n\n  const app = (...args: Args) =>\n    Effect.map(\n      Effect.promise(() =>\n        managed.runPromise(createRequestHandler(opts, beAdapter ?? \"custom\")),\n      ),\n      Effect.provideServiceEffect(AdapterArguments, makeAdapterArgs(...args)),\n    );\n\n  return async (...args: Args) => {\n    const result = await handle.pipe(\n      Effect.ap(app(...args)),\n      Effect.ap(toRequest(...args)),\n      Effect.withLogSpan(\"requestHandler\"),\n      managed.runPromise,\n    );\n\n    return result;\n  };\n};\n\nexport const createRequestHandler = <TRouter extends FileRouter>(\n  opts: RouteHandlerOptions<TRouter>,\n  beAdapter: string,\n) =>\n  Effect.gen(function* () {\n    const isDevelopment = yield* IsDevelopment;\n    const routerConfig = yield* extractRouterConfig(opts.router);\n\n    const handleDaemon = (() => {\n      if (opts.config?.handleDaemonPromise) {\n        return opts.config.handleDaemonPromise;\n      }\n      return isDevelopment ? \"void\" : \"await\";\n    })();\n    if (isDevelopment && handleDaemon === \"await\") {\n      return yield* new UploadThingError({\n        code: \"INVALID_SERVER_CONFIG\",\n        message: 'handleDaemonPromise: \"await\" is forbidden in development.',\n      });\n    }\n\n    const GET = Effect.gen(function* () {\n      return yield* HttpServerResponse.json(routerConfig);\n    });\n\n    const POST = Effect.gen(function* () {\n      const {\n        \"uploadthing-hook\": uploadthingHook,\n        \"x-uploadthing-package\": fePackage,\n        \"x-uploadthing-version\": clientVersion,\n      } = yield* HttpServerRequest.schemaHeaders(\n        Schema.Struct({\n          \"uploadthing-hook\": UploadThingHook.pipe(Schema.optional),\n          \"x-uploadthing-package\": Schema.String.pipe(\n            Schema.optionalWith({ default: () => \"unknown\" }),\n          ),\n          \"x-uploadthing-version\": Schema.String.pipe(\n            Schema.optionalWith({ default: () => pkgJson.version }),\n          ),\n        }),\n      );\n\n      if (clientVersion !== pkgJson.version) {\n        const serverVersion = pkgJson.version;\n        yield* Effect.logWarning(\n          \"Client version mismatch. Things may not work as expected, please sync your versions to ensure compatibility.\",\n        ).pipe(Effect.annotateLogs({ clientVersion, serverVersion }));\n      }\n\n      const { slug, actionType } = yield* HttpRouter.schemaParams(\n        Schema.Struct({\n          actionType: ActionType.pipe(Schema.optional),\n          slug: Schema.String,\n        }),\n      );\n\n      const uploadable = opts.router[slug];\n      if (!uploadable) {\n        const msg = `No file route found for slug ${slug}`;\n        yield* Effect.logError(msg);\n        return yield* new UploadThingError({\n          code: \"NOT_FOUND\",\n          message: msg,\n        });\n      }\n\n      const { body, fiber } = yield* Match.value({\n        actionType,\n        uploadthingHook,\n      }).pipe(\n        Match.when({ actionType: \"upload\", uploadthingHook: undefined }, () =>\n          handleUploadAction({\n            uploadable,\n            fePackage,\n            beAdapter,\n            slug,\n          }),\n        ),\n        Match.when({ actionType: undefined, uploadthingHook: \"callback\" }, () =>\n          handleCallbackRequest({ uploadable, fePackage, beAdapter }),\n        ),\n        Match.when({ actionType: undefined, uploadthingHook: \"error\" }, () =>\n          handleErrorRequest({ uploadable }),\n        ),\n        Match.orElse(() => Effect.succeed({ body: null, fiber: null })),\n      );\n\n      if (fiber) {\n        yield* Effect.logDebug(\"Running fiber as daemon\").pipe(\n          Effect.annotateLogs(\"handleDaemon\", handleDaemon),\n        );\n        if (handleDaemon === \"void\") {\n          // noop\n        } else if (handleDaemon === \"await\") {\n          yield* fiber.await;\n        } else if (typeof handleDaemon === \"function\") {\n          handleDaemon(Effect.runPromise(fiber.await));\n        }\n      }\n\n      yield* Effect.logDebug(\"Sending response\").pipe(\n        Effect.annotateLogs(\"body\", body),\n      );\n\n      return yield* HttpServerResponse.json(body);\n    }).pipe(\n      Effect.catchTags({\n        ParseError: (e) =>\n          HttpServerResponse.json(\n            formatError(\n              new UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"Invalid input\",\n                cause: e.message,\n              }),\n              opts.router,\n            ),\n            { status: 400 },\n          ),\n        UploadThingError: (e) =>\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n          HttpServerResponse.json(formatError(e, opts.router), {\n            status: getStatusCodeFromError(e),\n          }),\n      }),\n    );\n\n    const appendResponseHeaders = Effect.map(\n      HttpServerResponse.setHeader(\"x-uploadthing-version\", pkgJson.version),\n    );\n\n    return HttpRouter.empty.pipe(\n      HttpRouter.get(\"*\", GET),\n      HttpRouter.post(\"*\", POST),\n      HttpRouter.use(appendResponseHeaders),\n    );\n  }).pipe(Effect.withLogSpan(\"createRequestHandler\"));\n\nconst handleErrorRequest = (opts: { uploadable: AnyFileRoute }) =>\n  Effect.gen(function* () {\n    const { uploadable } = opts;\n    const request = yield* HttpServerRequest.HttpServerRequest;\n    const { apiKey } = yield* UTToken;\n    const verified = yield* verifySignature(\n      yield* request.text,\n      request.headers[\"x-uploadthing-signature\"] ?? null,\n      apiKey,\n    );\n    yield* Effect.logDebug(`Signature verified: ${verified}`);\n    if (!verified) {\n      yield* Effect.logError(\"Invalid signature\");\n      return yield* new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"Invalid signature\",\n      });\n    }\n\n    const requestInput = yield* HttpServerRequest.schemaBodyJson(\n      Schema.Struct({\n        fileKey: Schema.String,\n        error: Schema.String,\n      }),\n    );\n    yield* Effect.logDebug(\"Handling error callback request with input:\").pipe(\n      Effect.annotateLogs(\"json\", requestInput),\n    );\n\n    const adapterArgs = yield* AdapterArguments;\n    const fiber = yield* Effect.tryPromise({\n      try: async () =>\n        uploadable.onUploadError({\n          ...adapterArgs,\n          error: new UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: `Upload failed for ${requestInput.fileKey}: ${requestInput.error}`,\n          }),\n          fileKey: requestInput.fileKey,\n        }),\n      catch: (error) =>\n        new UploadThingError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to run onUploadError\",\n          cause: error,\n        }),\n    })\n      .pipe(\n        Effect.tapError((error) =>\n          Effect.logError(\n            \"Failed to run onUploadError. You probably shouldn't be throwing errors here.\",\n          ).pipe(Effect.annotateLogs(\"error\", error)),\n        ),\n      )\n      .pipe(Effect.ignoreLogged, Effect.forkDaemon);\n\n    return {\n      body: null,\n      fiber,\n    };\n  }).pipe(Effect.withLogSpan(\"handleErrorRequest\"));\n\nconst handleCallbackRequest = (opts: {\n  uploadable: AnyFileRoute;\n  fePackage: string;\n  beAdapter: string;\n}) =>\n  Effect.gen(function* () {\n    const { uploadable, fePackage, beAdapter } = opts;\n    const request = yield* HttpServerRequest.HttpServerRequest;\n    const { apiKey } = yield* UTToken;\n    const verified = yield* verifySignature(\n      yield* request.text,\n      request.headers[\"x-uploadthing-signature\"] ?? null,\n      apiKey,\n    );\n    yield* Effect.logDebug(`Signature verified: ${verified}`);\n    if (!verified) {\n      yield* Effect.logError(\"Invalid signature\");\n      return yield* new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"Invalid signature\",\n      });\n    }\n\n    const requestInput = yield* HttpServerRequest.schemaBodyJson(\n      Schema.Struct({\n        status: Schema.String,\n        file: UploadedFileData,\n        origin: Schema.String,\n        metadata: Schema.Record({ key: Schema.String, value: Schema.Unknown }),\n      }),\n    );\n    yield* Effect.logDebug(\"Handling callback request with input:\").pipe(\n      Effect.annotateLogs(\"json\", requestInput),\n    );\n\n    /**\n     * Run `.onUploadComplete` as a daemon to prevent the\n     * request from UT to potentially timeout.\n     */\n    const fiber = yield* Effect.gen(function* () {\n      const adapterArgs = yield* AdapterArguments;\n      const serverData = yield* Effect.tryPromise({\n        try: async () =>\n          uploadable.onUploadComplete({\n            ...adapterArgs,\n            file: {\n              ...requestInput.file,\n              get url() {\n                logDeprecationWarning(\n                  \"`file.url` is deprecated and will be removed in uploadthing v9. Use `file.ufsUrl` instead.\",\n                );\n                return requestInput.file.url;\n              },\n              get appUrl() {\n                logDeprecationWarning(\n                  \"`file.appUrl` is deprecated and will be removed in uploadthing v9. Use `file.ufsUrl` instead.\",\n                );\n                return requestInput.file.appUrl;\n              },\n            },\n            metadata: requestInput.metadata,\n          }) as Promise<unknown>,\n        catch: (error) =>\n          new UploadThingError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message:\n              \"Failed to run onUploadComplete. You probably shouldn't be throwing errors here.\",\n            cause: error,\n          }),\n      });\n      const payload = {\n        fileKey: requestInput.file.key,\n        callbackData: serverData ?? null,\n      };\n      yield* Effect.logDebug(\n        \"'onUploadComplete' callback finished. Sending response to UploadThing:\",\n      ).pipe(Effect.annotateLogs(\"callbackData\", payload));\n\n      const httpClient = (yield* HttpClient.HttpClient).pipe(\n        HttpClient.filterStatusOk,\n      );\n\n      yield* HttpClientRequest.post(`/callback-result`).pipe(\n        HttpClientRequest.prependUrl(requestInput.origin),\n        HttpClientRequest.setHeaders({\n          \"x-uploadthing-api-key\": Redacted.value(apiKey),\n          \"x-uploadthing-version\": pkgJson.version,\n          \"x-uploadthing-be-adapter\": beAdapter,\n          \"x-uploadthing-fe-package\": fePackage,\n        }),\n        HttpClientRequest.bodyJson(payload),\n        Effect.flatMap(httpClient.execute),\n        Effect.tapError(\n          logHttpClientError(\"Failed to register callback result\"),\n        ),\n        Effect.flatMap(\n          HttpClientResponse.schemaBodyJson(CallbackResultResponse),\n        ),\n        Effect.tap(Effect.log(\"Sent callback result to UploadThing\")),\n        Effect.scoped,\n      );\n    }).pipe(Effect.ignoreLogged, Effect.forkDaemon);\n\n    return { body: null, fiber };\n  }).pipe(Effect.withLogSpan(\"handleCallbackRequest\"));\n\nconst runRouteMiddleware = (opts: {\n  json: typeof UploadActionPayload.Type;\n  uploadable: AnyFileRoute;\n}) =>\n  Effect.gen(function* () {\n    const {\n      json: { files, input },\n      uploadable,\n    } = opts;\n\n    yield* Effect.logDebug(\"Running middleware\");\n    const adapterArgs = yield* AdapterArguments;\n    const metadata = yield* Effect.tryPromise({\n      try: async () =>\n        uploadable.middleware({\n          ...adapterArgs,\n          input,\n          files,\n        }),\n      catch: (error) =>\n        error instanceof UploadThingError\n          ? error\n          : new UploadThingError({\n              code: \"INTERNAL_SERVER_ERROR\",\n              message: \"Failed to run middleware\",\n              cause: error,\n            }),\n    });\n\n    if (metadata[UTFiles] && metadata[UTFiles].length !== files.length) {\n      const msg = `Expected files override to have the same length as original files, got ${metadata[UTFiles].length} but expected ${files.length}`;\n      yield* Effect.logError(msg);\n      return yield* new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"Files override must have the same length as files\",\n        cause: msg,\n      });\n    }\n\n    // Attach customIds from middleware to the files\n    const filesWithCustomIds = yield* Effect.forEach(files, (file, idx) =>\n      Effect.gen(function* () {\n        const theirs = metadata[UTFiles]?.[idx];\n        if (theirs && theirs.size !== file.size) {\n          yield* Effect.logWarning(\n            \"File size mismatch. Reverting to original size\",\n          );\n        }\n        return {\n          name: theirs?.name ?? file.name,\n          size: file.size,\n          type: file.type,\n          customId: theirs?.customId,\n          lastModified: theirs?.lastModified ?? Date.now(),\n        };\n      }),\n    );\n\n    return {\n      metadata,\n      filesWithCustomIds,\n      preferredRegion: metadata[UTRegion],\n    };\n  }).pipe(Effect.withLogSpan(\"runRouteMiddleware\"));\n\nconst handleUploadAction = (opts: {\n  uploadable: AnyFileRoute;\n  fePackage: string;\n  beAdapter: string;\n  slug: string;\n}) =>\n  Effect.gen(function* () {\n    const httpClient = (yield* HttpClient.HttpClient).pipe(\n      HttpClient.filterStatusOk,\n    );\n    const { uploadable, fePackage, beAdapter, slug } = opts;\n    const json = yield* HttpServerRequest.schemaBodyJson(UploadActionPayload);\n    yield* Effect.logDebug(\"Handling upload request\").pipe(\n      Effect.annotateLogs(\"json\", json),\n    );\n\n    // validate the input\n    yield* Effect.logDebug(\"Parsing user input\");\n    const parsedInput = yield* Effect.tryPromise({\n      try: () => getParseFn(uploadable.inputParser)(json.input),\n      catch: (error) =>\n        new UploadThingError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid input\",\n          cause: error,\n        }),\n    });\n    yield* Effect.logDebug(\"Input parsed successfully\").pipe(\n      Effect.annotateLogs(\"input\", parsedInput),\n    );\n\n    const { metadata, filesWithCustomIds, preferredRegion } =\n      yield* runRouteMiddleware({\n        json: { input: parsedInput, files: json.files },\n        uploadable,\n      });\n\n    yield* Effect.logDebug(\"Parsing route config\").pipe(\n      Effect.annotateLogs(\"routerConfig\", uploadable.routerConfig),\n    );\n    const parsedConfig = yield* fillInputRouteConfig(\n      uploadable.routerConfig,\n    ).pipe(\n      Effect.catchTag(\n        \"InvalidRouteConfig\",\n        (err) =>\n          new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid route config\",\n            cause: err,\n          }),\n      ),\n    );\n    yield* Effect.logDebug(\"Route config parsed successfully\").pipe(\n      Effect.annotateLogs(\"routeConfig\", parsedConfig),\n    );\n\n    yield* Effect.logDebug(\n      \"Validating files meet the config requirements\",\n    ).pipe(Effect.annotateLogs(\"files\", json.files));\n    yield* assertFilesMeetConfig(json.files, parsedConfig).pipe(\n      Effect.mapError(\n        (e) =>\n          new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: `Invalid config: ${e._tag}`,\n            cause: \"reason\" in e ? e.reason : e.message,\n          }),\n      ),\n    );\n    yield* Effect.logDebug(\"Files validated.\");\n\n    const fileUploadRequests = yield* Effect.forEach(\n      filesWithCustomIds,\n      (file) =>\n        Effect.map(matchFileType(file, objectKeys(parsedConfig)), (type) => ({\n          name: file.name,\n          size: file.size,\n          type: file.type || type,\n          lastModified: file.lastModified,\n          customId: file.customId,\n          contentDisposition:\n            parsedConfig[type]?.contentDisposition ?? \"inline\",\n          acl: parsedConfig[type]?.acl,\n        })),\n    ).pipe(\n      Effect.catchTags({\n        /** Shouldn't happen since config is validated above so just dying is fine I think */\n        InvalidFileType: (e) => Effect.die(e),\n        UnknownFileType: (e) => Effect.die(e),\n      }),\n    );\n\n    const routeOptions = uploadable.routeOptions;\n    const { apiKey, appId } = yield* UTToken;\n    const ingestUrl = yield* IngestUrl(preferredRegion);\n    const isDev = yield* IsDevelopment;\n\n    yield* Effect.logDebug(\"Generating presigned URLs\").pipe(\n      Effect.annotateLogs(\"fileUploadRequests\", fileUploadRequests),\n      Effect.annotateLogs(\"ingestUrl\", ingestUrl),\n    );\n    const presignedUrls = yield* Effect.forEach(\n      fileUploadRequests,\n      (file) =>\n        Effect.gen(function* () {\n          const key = yield* generateKey(\n            file,\n            appId,\n            routeOptions.getFileHashParts,\n          );\n\n          const url = yield* generateSignedURL(`${ingestUrl}/${key}`, apiKey, {\n            ttlInSeconds: routeOptions.presignedURLTTL,\n            data: {\n              \"x-ut-identifier\": appId,\n              \"x-ut-file-name\": file.name,\n              \"x-ut-file-size\": file.size,\n              \"x-ut-file-type\": file.type,\n              \"x-ut-slug\": slug,\n              \"x-ut-custom-id\": file.customId,\n              \"x-ut-content-disposition\": file.contentDisposition,\n              \"x-ut-acl\": file.acl,\n            },\n          });\n          return { url, key };\n        }),\n      { concurrency: \"unbounded\" },\n    );\n\n    const serverReq = yield* HttpServerRequest.HttpServerRequest;\n    const requestUrl = yield* HttpServerRequest.toURL(serverReq);\n\n    const devHookRequest = yield* Config.string(\"callbackUrl\").pipe(\n      Config.withDefault(requestUrl.origin + requestUrl.pathname),\n      Effect.map((url) =>\n        HttpClientRequest.post(url).pipe(\n          HttpClientRequest.appendUrlParam(\"slug\", slug),\n        ),\n      ),\n    );\n\n    const metadataRequest = HttpClientRequest.post(\"/route-metadata\").pipe(\n      HttpClientRequest.prependUrl(ingestUrl),\n      HttpClientRequest.setHeaders({\n        \"x-uploadthing-api-key\": Redacted.value(apiKey),\n        \"x-uploadthing-version\": pkgJson.version,\n        \"x-uploadthing-be-adapter\": beAdapter,\n        \"x-uploadthing-fe-package\": fePackage,\n      }),\n      HttpClientRequest.bodyJson({\n        fileKeys: presignedUrls.map(({ key }) => key),\n        metadata: metadata,\n        isDev,\n        callbackUrl: devHookRequest.url,\n        callbackSlug: slug,\n        awaitServerData: routeOptions.awaitServerData ?? true,\n      }),\n      Effect.flatMap(httpClient.execute),\n    );\n\n    const handleDevStreamError = Effect.fn(\"handleDevStreamError\")(function* (\n      err: HttpClientError.ResponseError,\n      chunk: string,\n    ) {\n      const schema = Schema.parseJson(\n        Schema.Struct({ file: UploadedFileData }),\n      );\n      const parsedChunk = yield* Schema.decodeUnknown(schema)(chunk);\n      const key = parsedChunk.file.key;\n\n      yield* Effect.logError(\n        \"Failed to forward callback request from dev stream\",\n      ).pipe(Effect.annotateLogs({ fileKey: key, error: err.message }));\n\n      const httpResponse = yield* HttpClientRequest.post(\n        \"/callback-result\",\n      ).pipe(\n        HttpClientRequest.prependUrl(ingestUrl),\n        HttpClientRequest.setHeaders({\n          \"x-uploadthing-api-key\": Redacted.value(apiKey),\n          \"x-uploadthing-version\": pkgJson.version,\n          \"x-uploadthing-be-adapter\": beAdapter,\n          \"x-uploadthing-fe-package\": fePackage,\n        }),\n        HttpClientRequest.bodyJson({\n          fileKey: key,\n          error: `Failed to forward callback request from dev stream: ${err.message}`,\n        }),\n        Effect.flatMap(httpClient.execute),\n      );\n\n      yield* logHttpClientResponse(\"Reported callback error to UploadThing\")(\n        httpResponse,\n      );\n    });\n\n    // Send metadata to UT server (non blocking as a daemon)\n    // In dev, keep the stream open and simulate the callback requests as\n    // files complete uploading\n    const fiber = yield* Effect.if(isDev, {\n      onTrue: () =>\n        metadataRequest.pipe(\n          Effect.tapBoth({\n            onSuccess: logHttpClientResponse(\"Registered metadata\", {\n              mixin: \"None\", // We're reading the stream so can't call a body mixin\n            }),\n            onFailure: logHttpClientError(\"Failed to register metadata\"),\n          }),\n          HttpClientResponse.stream,\n          handleJsonLineStream(MetadataFetchStreamPart, (chunk) =>\n            devHookRequest.pipe(\n              HttpClientRequest.setHeaders({\n                \"uploadthing-hook\": chunk.hook,\n                \"x-uploadthing-signature\": chunk.signature,\n              }),\n              HttpClientRequest.setBody(\n                HttpBody.text(chunk.payload, \"application/json\"),\n              ),\n              httpClient.execute,\n              Effect.tap(\n                logHttpClientResponse(\n                  \"Successfully forwarded callback request from dev stream\",\n                ),\n              ),\n              Effect.catchTag(\"ResponseError\", (err) =>\n                handleDevStreamError(err, chunk.payload),\n              ),\n              Effect.annotateLogs(chunk),\n              Effect.asVoid,\n              Effect.ignoreLogged,\n              Effect.scoped,\n            ),\n          ),\n        ),\n      onFalse: () =>\n        metadataRequest.pipe(\n          Effect.tapBoth({\n            onSuccess: logHttpClientResponse(\"Registered metadata\"),\n            onFailure: logHttpClientError(\"Failed to register metadata\"),\n          }),\n          Effect.flatMap(\n            HttpClientResponse.schemaBodyJson(MetadataFetchResponse),\n          ),\n          Effect.scoped,\n        ),\n    }).pipe(Effect.forkDaemon);\n\n    const presigneds = presignedUrls.map((p, i) => ({\n      url: p.url,\n      key: p.key,\n      name: fileUploadRequests[i]!.name,\n      customId: fileUploadRequests[i]!.customId ?? null,\n    }));\n\n    yield* Effect.logInfo(\"Sending presigned URLs to client\").pipe(\n      Effect.annotateLogs(\"presignedUrls\", presigneds),\n    );\n\n    return {\n      body: presigneds satisfies UTEvents[\"upload\"][\"out\"],\n      fiber,\n    };\n  }).pipe(Effect.withLogSpan(\"handleUploadAction\"));\n","import type {\n  FileRouterInputConfig,\n  Json,\n  RouteOptions,\n  UploadThingError,\n} from \"@uploadthing/shared\";\n\nimport { defaultErrorFormatter } from \"./error-formatter\";\nimport type {\n  AnyBuiltUploaderTypes,\n  AnyFileRoute,\n  UnsetMarker,\n  UploadBuilder,\n} from \"./types\";\n\nfunction internalCreateBuilder<\n  TAdapterFnArgs extends Record<string, unknown>,\n  TRouteOptions extends RouteOptions,\n  TErrorShape extends Json = { message: string },\n>(\n  initDef: Partial<AnyFileRoute> = {},\n): UploadBuilder<{\n  _routeOptions: TRouteOptions;\n  _input: { in: UnsetMarker; out: UnsetMarker };\n  _metadata: UnsetMarker;\n  _adapterFnArgs: TAdapterFnArgs;\n  _errorShape: TErrorShape;\n  _errorFn: UnsetMarker;\n  _output: UnsetMarker;\n}> {\n  const _def: AnyFileRoute = {\n    $types: {} as AnyBuiltUploaderTypes,\n    // Default router config\n    routerConfig: {\n      image: {\n        maxFileSize: \"4MB\",\n      },\n    },\n    routeOptions: {\n      awaitServerData: true,\n    },\n\n    inputParser: {\n      parseAsync: () => Promise.resolve(undefined),\n      _input: undefined,\n      _output: undefined,\n    },\n\n    middleware: () => ({}),\n    onUploadError: () => {\n      // noop\n    },\n    onUploadComplete: () => undefined,\n\n    errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,\n\n    // Overload with properties passed in\n    ...initDef,\n  };\n\n  return {\n    input(userParser) {\n      return internalCreateBuilder({\n        ..._def,\n        inputParser: userParser,\n      }) as UploadBuilder<any>;\n    },\n    middleware(userMiddleware) {\n      return internalCreateBuilder({\n        ..._def,\n        middleware: userMiddleware,\n      }) as UploadBuilder<any>;\n    },\n    onUploadComplete(userUploadComplete) {\n      return {\n        ..._def,\n        onUploadComplete: userUploadComplete,\n      } as AnyFileRoute;\n    },\n    onUploadError(userOnUploadError) {\n      return internalCreateBuilder({\n        ..._def,\n        onUploadError: userOnUploadError,\n      }) as UploadBuilder<any>;\n    },\n  };\n}\n\nexport type CreateBuilderOptions<TErrorShape extends Json> = {\n  errorFormatter: (err: UploadThingError) => TErrorShape;\n};\n\n/**\n * Create a builder for your backend adapter.\n * Refer to the existing adapters for examples on how to use this function.\n * @public\n *\n * @param opts - Options for the builder\n * @returns A file route builder for making UploadThing file routes\n */\nexport function createBuilder<\n  TAdapterFnArgs extends Record<string, unknown>,\n  TErrorShape extends Json = { message: string },\n>(opts?: CreateBuilderOptions<TErrorShape>) {\n  return <TRouteOptions extends RouteOptions>(\n    input: FileRouterInputConfig,\n    config?: TRouteOptions,\n  ): UploadBuilder<{\n    _routeOptions: TRouteOptions;\n    _input: { in: UnsetMarker; out: UnsetMarker };\n    _metadata: UnsetMarker;\n    _adapterFnArgs: TAdapterFnArgs;\n    _errorShape: TErrorShape;\n    _errorFn: UnsetMarker;\n    _output: UnsetMarker;\n  }> => {\n    return internalCreateBuilder<TAdapterFnArgs, TRouteOptions, TErrorShape>({\n      routerConfig: input,\n      routeOptions: config ?? {},\n      ...opts,\n    });\n  };\n}\n"],"mappings":"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"}