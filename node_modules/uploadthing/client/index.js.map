{"version":3,"file":"index.js","names":["file: File","rangeStart: number","presigned: NewPresignedUrl","opts: {\n    traceHeaders: TraceHeaders;\n    onUploadProgress?:\n      | ((opts: { loaded: number; delta: number }) => void)\n      | undefined;\n  }","opts: {\n    traceHeaders: TraceHeaders;\n    onUploadProgress?: (progressEvent: {\n      loaded: number;\n      delta: number;\n    }) => void;\n  }","endpoint: TEndpoint","opts: UploadFilesOptions<TRouter[TEndpoint]>","version","file: File","routeConfig: ExpandedRouteConfig","initOpts?: GenerateUploaderOptions","slug: EndpointArg<TRouter, TEndpoint>","opts: Omit<\n      CreateUploadOptions<TRouter[TEndpoint]>,\n      keyof GenerateUploaderOptions\n    >","fetchFn: FetchEsque","presigned: NewPresignedUrl","UploadPausedError","file?: File","file","UploadAbortedError","file?: T","opts: Omit<\n      UploadFilesOptions<TRouter[TEndpoint]>,\n      keyof GenerateUploaderOptions\n    >"],"sources":["../src/_internal/upload-browser.ts","../src/client.ts"],"sourcesContent":["import { unsafeCoerce } from \"effect/Function\";\nimport * as Micro from \"effect/Micro\";\nimport { hasProperty, isRecord } from \"effect/Predicate\";\n\nimport type { FetchContext, FetchError } from \"@uploadthing/shared\";\nimport { fetchEff, UploadThingError } from \"@uploadthing/shared\";\n\nimport { version } from \"../../package.json\";\nimport type {\n  ClientUploadedFileData,\n  FileRouter,\n  inferEndpointOutput,\n  NewPresignedUrl,\n  UploadFilesOptions,\n} from \"../types\";\nimport { logDeprecationWarning } from \"./deprecations\";\nimport type { TraceHeaders } from \"./random-hex\";\nimport { generateTraceHeaders } from \"./random-hex\";\nimport type { UploadPutResult } from \"./types\";\nimport { createUTReporter } from \"./ut-reporter\";\n\nconst uploadWithProgress = (\n  file: File,\n  rangeStart: number,\n  presigned: NewPresignedUrl,\n  opts: {\n    traceHeaders: TraceHeaders;\n    onUploadProgress?:\n      | ((opts: { loaded: number; delta: number }) => void)\n      | undefined;\n  },\n) =>\n  Micro.async<unknown, UploadThingError, FetchContext>((resume) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"PUT\", presigned.url, true);\n    xhr.setRequestHeader(\"Range\", `bytes=${rangeStart}-`);\n    xhr.setRequestHeader(\"x-uploadthing-version\", version);\n    xhr.setRequestHeader(\"b3\", opts.traceHeaders.b3);\n    xhr.setRequestHeader(\"traceparent\", opts.traceHeaders.traceparent);\n\n    xhr.responseType = \"json\";\n\n    let previousLoaded = 0;\n    xhr.upload.addEventListener(\"progress\", ({ loaded }) => {\n      const delta = loaded - previousLoaded;\n      opts.onUploadProgress?.({ loaded, delta });\n      previousLoaded = loaded;\n    });\n    xhr.addEventListener(\"load\", () => {\n      if (xhr.status >= 200 && xhr.status < 300 && isRecord(xhr.response)) {\n        if (hasProperty(xhr.response, \"error\")) {\n          resume(\n            new UploadThingError({\n              code: \"UPLOAD_FAILED\",\n              message: String(xhr.response.error),\n              data: xhr.response as never,\n            }),\n          );\n        } else {\n          resume(Micro.succeed(xhr.response));\n        }\n      } else {\n        resume(\n          new UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: `XHR failed ${xhr.status} ${xhr.statusText}`,\n            data: xhr.response as never,\n          }),\n        );\n      }\n    });\n\n    // Is there a case when the client would throw and\n    // ingest server not knowing about it? idts?\n    xhr.addEventListener(\"error\", () => {\n      resume(\n        new UploadThingError({\n          code: \"UPLOAD_FAILED\",\n        }),\n      );\n    });\n\n    const formData = new FormData();\n    /**\n     * iOS/React Native FormData handling requires special attention:\n     *\n     * Issue: In React Native, iOS crashes with \"attempt to insert nil object\" when appending File directly\n     * to FormData. This happens because iOS tries to create NSDictionary from the file object and expects\n     * specific structure {uri, type, name}.\n     *\n     *\n     * Note: Don't try to use Blob or modify File object - iOS specifically needs plain object\n     * with these properties to create valid NSDictionary.\n     */\n    if (\"uri\" in file) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      formData.append(\"file\", {\n        uri: file.uri as string,\n        type: file.type,\n        name: file.name,\n        ...(rangeStart > 0 && { range: rangeStart }),\n      } as any);\n    } else {\n      formData.append(\"file\", rangeStart > 0 ? file.slice(rangeStart) : file);\n    }\n    xhr.send(formData);\n\n    return Micro.sync(() => xhr.abort());\n  });\n\nexport const uploadFile = <\n  TRouter extends FileRouter,\n  TEndpoint extends keyof TRouter,\n  TServerOutput = inferEndpointOutput<TRouter[TEndpoint]>,\n>(\n  file: File,\n  presigned: NewPresignedUrl,\n  opts: {\n    traceHeaders: TraceHeaders;\n    onUploadProgress?: (progressEvent: {\n      loaded: number;\n      delta: number;\n    }) => void;\n  },\n) =>\n  fetchEff(presigned.url, {\n    method: \"HEAD\",\n    headers: opts.traceHeaders,\n  }).pipe(\n    Micro.map(({ headers }) =>\n      parseInt(headers.get(\"x-ut-range-start\") ?? \"0\", 10),\n    ),\n    Micro.tap((start) =>\n      opts.onUploadProgress?.({\n        delta: start,\n        loaded: start,\n      }),\n    ),\n    Micro.flatMap((start) =>\n      uploadWithProgress(file, start, presigned, {\n        traceHeaders: opts.traceHeaders,\n        onUploadProgress: (progressEvent) =>\n          opts.onUploadProgress?.({\n            delta: progressEvent.delta,\n            loaded: progressEvent.loaded + start,\n          }),\n      }),\n    ),\n    Micro.map(unsafeCoerce<unknown, UploadPutResult<TServerOutput>>),\n    Micro.map((uploadResponse) => ({\n      name: file.name,\n      size: file.size,\n      key: presigned.key,\n      lastModified: file.lastModified,\n      serverData: uploadResponse.serverData,\n      get url() {\n        logDeprecationWarning(\n          \"`file.url` is deprecated and will be removed in uploadthing v9. Use `file.ufsUrl` instead.\",\n        );\n        return uploadResponse.url;\n      },\n      get appUrl() {\n        logDeprecationWarning(\n          \"`file.appUrl` is deprecated and will be removed in uploadthing v9. Use `file.ufsUrl` instead.\",\n        );\n        return uploadResponse.appUrl;\n      },\n      ufsUrl: uploadResponse.ufsUrl,\n      customId: presigned.customId,\n      type: file.type,\n      fileHash: uploadResponse.fileHash,\n    })),\n  );\n\nexport const uploadFilesInternal = <\n  TRouter extends FileRouter,\n  TEndpoint extends keyof TRouter,\n  TServerOutput = inferEndpointOutput<TRouter[TEndpoint]>,\n>(\n  endpoint: TEndpoint,\n  opts: UploadFilesOptions<TRouter[TEndpoint]>,\n): Micro.Micro<\n  ClientUploadedFileData<TServerOutput>[],\n  UploadThingError | FetchError,\n  FetchContext\n> => {\n  // classic service right here\n  const traceHeaders = generateTraceHeaders();\n  const reportEventToUT = createUTReporter({\n    endpoint: String(endpoint),\n    package: opts.package,\n    url: opts.url,\n    headers: opts.headers,\n    traceHeaders,\n  });\n\n  const totalSize = opts.files.reduce((acc, f) => acc + f.size, 0);\n  let totalLoaded = 0;\n\n  return Micro.flatMap(\n    reportEventToUT(\"upload\", {\n      input: \"input\" in opts ? opts.input : null,\n      files: opts.files.map((f) => ({\n        name: f.name,\n        size: f.size,\n        type: f.type,\n        lastModified: f.lastModified,\n      })),\n    }),\n    (presigneds) =>\n      Micro.forEach(\n        presigneds,\n        (presigned, i) =>\n          Micro.flatMap(\n            Micro.sync(() =>\n              opts.onUploadBegin?.({ file: opts.files[i]!.name }),\n            ),\n            () =>\n              uploadFile<TRouter, TEndpoint, TServerOutput>(\n                opts.files[i]!,\n                presigned,\n                {\n                  traceHeaders,\n                  onUploadProgress: (ev) => {\n                    totalLoaded += ev.delta;\n                    opts.onUploadProgress?.({\n                      file: opts.files[i]!,\n                      progress: (ev.loaded / opts.files[i]!.size) * 100,\n                      loaded: ev.loaded,\n                      delta: ev.delta,\n                      totalLoaded,\n                      totalProgress: totalLoaded / totalSize,\n                    });\n                  },\n                },\n              ),\n          ),\n        { concurrency: 6 },\n      ),\n  );\n};\n","import * as Arr from \"effect/Array\";\nimport * as Micro from \"effect/Micro\";\n\nimport type { ExpandedRouteConfig, FetchEsque } from \"@uploadthing/shared\";\nimport {\n  createIdentityProxy,\n  FetchContext,\n  fileSizeToBytes,\n  matchFileType,\n  objectKeys,\n  resolveMaybeUrlArg,\n  UploadAbortedError,\n  UploadPausedError,\n} from \"@uploadthing/shared\";\n\nimport * as pkgJson from \"../package.json\";\nimport type { Deferred } from \"./_internal/deferred\";\nimport { createDeferred } from \"./_internal/deferred\";\nimport { generateTraceHeaders } from \"./_internal/random-hex\";\nimport { uploadFile, uploadFilesInternal } from \"./_internal/upload-browser\";\nimport { createUTReporter } from \"./_internal/ut-reporter\";\nimport type {\n  ClientUploadedFileData,\n  CreateUploadOptions,\n  EndpointArg,\n  FileRouter,\n  GenerateUploaderOptions,\n  inferEndpointInput,\n  inferEndpointOutput,\n  NewPresignedUrl,\n  RouteRegistry,\n  UploadFilesOptions,\n} from \"./types\";\n\nexport const version = pkgJson.version;\n\nexport {\n  /** @public */\n  generateClientDropzoneAccept,\n  /** @public */\n  generateMimeTypes,\n  /** @public */\n  generatePermittedFileTypes,\n  /** @public */\n  bytesToFileSize,\n  /** @public */\n  allowedContentTextLabelGenerator,\n  /** @public */\n  UploadAbortedError,\n  /** @public */\n  UploadPausedError,\n} from \"@uploadthing/shared\";\n\n/**\n * Validate that a file is of a valid type given a route config\n * @public\n */\nexport const isValidFileType = (\n  file: File,\n  routeConfig: ExpandedRouteConfig,\n): boolean =>\n  Micro.runSync(\n    matchFileType(file, objectKeys(routeConfig)).pipe(\n      Micro.map((type) => file.type.includes(type)),\n      Micro.orElseSucceed(() => false),\n    ),\n  );\n\n/**\n * Validate that a file is of a valid size given a route config\n * @public\n */\nexport const isValidFileSize = (\n  file: File,\n  routeConfig: ExpandedRouteConfig,\n): boolean =>\n  Micro.runSync(\n    matchFileType(file, objectKeys(routeConfig)).pipe(\n      Micro.flatMap((type) => fileSizeToBytes(routeConfig[type]!.maxFileSize)),\n      Micro.map((maxFileSize) => file.size <= maxFileSize),\n      Micro.orElseSucceed(() => false),\n    ),\n  );\n\n/**\n * Generate a typed uploader for a given FileRouter\n * @public\n */\nexport const genUploader = <TRouter extends FileRouter>(\n  initOpts?: GenerateUploaderOptions,\n) => {\n  const routeRegistry = createIdentityProxy<RouteRegistry<TRouter>>();\n\n  const controllableUpload = async <\n    TEndpoint extends keyof TRouter,\n    TServerOutput = inferEndpointOutput<TRouter[TEndpoint]>,\n  >(\n    slug: EndpointArg<TRouter, TEndpoint>,\n    opts: Omit<\n      CreateUploadOptions<TRouter[TEndpoint]>,\n      keyof GenerateUploaderOptions\n    >,\n  ) => {\n    const uploads = new Map<\n      File,\n      {\n        presigned: NewPresignedUrl;\n        deferred: Deferred<ClientUploadedFileData<TServerOutput>>;\n      }\n    >();\n\n    const endpoint = typeof slug === \"function\" ? slug(routeRegistry) : slug;\n\n    const traceHeaders = generateTraceHeaders();\n    const utReporter = createUTReporter({\n      endpoint: String(endpoint),\n      package: initOpts?.package ?? \"uploadthing/client\",\n      url: resolveMaybeUrlArg(initOpts?.url),\n      headers: opts.headers,\n      traceHeaders,\n    });\n    const fetchFn: FetchEsque = initOpts?.fetch ?? window.fetch;\n\n    const presigneds = await Micro.runPromise(\n      utReporter(\"upload\", {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        input: \"input\" in opts ? (opts.input as any) : null,\n        files: opts.files.map((f) => ({\n          name: f.name,\n          size: f.size,\n          type: f.type,\n          lastModified: f.lastModified,\n        })),\n      }).pipe(Micro.provideService(FetchContext, fetchFn)),\n    );\n\n    const totalSize = opts.files.reduce((acc, f) => acc + f.size, 0);\n    let totalLoaded = 0;\n\n    const uploadEffect = (file: File, presigned: NewPresignedUrl) =>\n      uploadFile(file, presigned, {\n        traceHeaders,\n        onUploadProgress: (progressEvent) => {\n          totalLoaded += progressEvent.delta;\n          opts.onUploadProgress?.({\n            ...progressEvent,\n            file,\n            progress: Math.round((progressEvent.loaded / file.size) * 100),\n            totalLoaded,\n            totalProgress: Math.round((totalLoaded / totalSize) * 100),\n          });\n        },\n      }).pipe(Micro.provideService(FetchContext, fetchFn));\n\n    for (const [i, p] of presigneds.entries()) {\n      const file = opts.files[i];\n      if (!file) continue;\n\n      const deferred = createDeferred<ClientUploadedFileData<TServerOutput>>();\n      uploads.set(file, { deferred, presigned: p });\n\n      void Micro.runPromiseExit(uploadEffect(file, p), {\n        signal: deferred.ac.signal,\n      })\n        .then((result) => {\n          if (result._tag === \"Success\") {\n            return deferred.resolve(result.value);\n          } else if (result.cause._tag === \"Interrupt\") {\n            throw new UploadPausedError();\n          }\n          throw Micro.causeSquash(result.cause);\n        })\n        .catch((err) => {\n          if (err instanceof UploadPausedError) return;\n          deferred.reject(err);\n        });\n    }\n\n    /**\n     * Pause an ongoing upload\n     * @param file The file upload you want to pause. Can be omitted to pause all files\n     */\n    const pauseUpload = (file?: File) => {\n      const files = Arr.ensure(file ?? opts.files);\n      for (const file of files) {\n        const upload = uploads.get(file);\n        if (!upload) return;\n\n        if (upload.deferred.ac.signal.aborted) {\n          // Cancel the upload if it's already been paused\n          throw new UploadAbortedError();\n        }\n\n        upload.deferred.ac.abort();\n      }\n    };\n\n    /**\n     * Resume a paused upload\n     * @param file The file upload you want to resume. Can be omitted to resume all files\n     */\n    const resumeUpload = (file?: File) => {\n      const files = Arr.ensure(file ?? opts.files);\n      for (const file of files) {\n        const upload = uploads.get(file);\n        if (!upload) throw \"No upload found\";\n\n        upload.deferred.ac = new AbortController();\n        void Micro.runPromiseExit(uploadEffect(file, upload.presigned), {\n          signal: upload.deferred.ac.signal,\n        })\n          .then((result) => {\n            if (result._tag === \"Success\") {\n              return upload.deferred.resolve(result.value);\n            } else if (result.cause._tag === \"Interrupt\") {\n              throw new UploadPausedError();\n            }\n            throw Micro.causeSquash(result.cause);\n          })\n          .catch((err) => {\n            if (err instanceof UploadPausedError) return;\n            upload.deferred.reject(err);\n          });\n      }\n    };\n\n    /**\n     * Wait for an upload to complete\n     * @param file The file upload you want to wait for. Can be omitted to wait for all files\n     */\n    const done = async <T extends File | void = void>(\n      file?: T,\n    ): Promise<\n      T extends File\n        ? ClientUploadedFileData<TServerOutput>\n        : ClientUploadedFileData<TServerOutput>[]\n    > => {\n      const promises = [];\n\n      const files = Arr.ensure(file ?? opts.files);\n      for (const file of files) {\n        const upload = uploads.get(file);\n        if (!upload) throw \"No upload found\";\n\n        promises.push(upload.deferred.promise);\n      }\n\n      const results = await Promise.all(promises);\n      return (file ? results[0] : results) as never;\n    };\n\n    return { pauseUpload, resumeUpload, done };\n  };\n\n  /**\n   * One step upload function that both requests presigned URLs\n   * and then uploads the files to UploadThing\n   */\n  const typedUploadFiles = <TEndpoint extends keyof TRouter>(\n    slug: EndpointArg<TRouter, TEndpoint>,\n    opts: Omit<\n      UploadFilesOptions<TRouter[TEndpoint]>,\n      keyof GenerateUploaderOptions\n    >,\n  ) => {\n    const endpoint = typeof slug === \"function\" ? slug(routeRegistry) : slug;\n    const fetchFn: FetchEsque = initOpts?.fetch ?? window.fetch;\n\n    return uploadFilesInternal<TRouter, TEndpoint>(endpoint, {\n      ...opts,\n      skipPolling: {} as never, // Remove in a future version, it's type right not is an ErrorMessage<T> to help migrations.\n      url: resolveMaybeUrlArg(initOpts?.url),\n      package: initOpts?.package ?? \"uploadthing/client\",\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      input: (opts as any).input as inferEndpointInput<TRouter[TEndpoint]>,\n    })\n      .pipe(Micro.provideService(FetchContext, fetchFn), (effect) =>\n        Micro.runPromiseExit(effect, opts.signal && { signal: opts.signal }),\n      )\n      .then((exit) => {\n        if (exit._tag === \"Success\") {\n          return exit.value;\n        } else if (exit.cause._tag === \"Interrupt\") {\n          throw new UploadAbortedError();\n        }\n        throw Micro.causeSquash(exit.cause);\n      });\n  };\n\n  return {\n    uploadFiles: typedUploadFiles,\n    createUpload: controllableUpload,\n    /**\n     * Identity object that can be used instead of raw strings\n     * that allows \"Go to definition\" in your IDE to bring you\n     * to the backend definition of a route.\n     */\n    routeRegistry,\n  };\n};\n"],"mappings":"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"}